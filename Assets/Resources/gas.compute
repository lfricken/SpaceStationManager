
struct Delta
{
	double deltas[4];
};

typedef RWStructuredBuffer<Delta> ArrayDelta;
typedef RWStructuredBuffer<double> ArrayDouble;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals ///
ArrayDelta DeltasRead;
ArrayDelta Deltas;

ArrayDouble PressureRead;
ArrayDouble Pressure;

ArrayInt IsBlocked;
ArrayInt DebugData;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;

/////////////
int NumSides = 4;
int ResolutionX;
float ViscosityGlobal;
float DtGlobal;
static int2 Offsets[4] =
{
	+int2(1, 2047483647),
	-int2(0, 1),
	-int2(1, 0),
	+int2(0, 1)
};
/////////////

int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

float4 colorGradient(double value, double min, double  middle, double max)
{
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	// TODO extend this to purple and toward white 
	// (white is ok since it will be surrounded by purple)
	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - middle) / (max - middle));
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - min) / (middle - min));
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render
[numthreads(16, 16, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;

	float4 c = float4(1, 0, 1, 1);

	double p = Pressure[at(pos)];
	bool isBlocked = IsBlocked[at(pos)];

	if(isBlocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(p, 0, 0.5, 1);
	}

	// dont count the pressure in the boundaries
	if(!isBlocked)
		InterlockedAdd(DebugData[0], int(p * 1000));

	RenderTexture[pos] = c;
	VelocityMap[pos] = colorGradient(Deltas[at(pos)].deltas[0], -1.0, 0.0, 1.0);
}

////////////
/// swap ///
////////////
#pragma kernel copy_all
[numthreads(16, 16, 1)]
void copy_all(uint3 pix : SV_DispatchThreadID)
{
	//swap_core(pix.xy, pressure, pressureRead);
}

void calc_forces(int2 pos, ArrayDouble p, ArrayDelta d)
{
	for(int side = 0; side < NumSides; ++side)
	{
		double pressure = p[at(pos)];
		int2 offset = Offsets[side];
		double otherPressure = p[at(pos + offset)];
		double difference = pressure - otherPressure;
		d[at(pos)].deltas[side] += max(0, difference / 10.0);
	}
	DebugData[0] = 0;
}
#pragma kernel apply_diffusion_forces
[numthreads(16, 16, 1)]
void apply_diffusion_forces(uint3 pix : SV_DispatchThreadID)
{
	calc_forces(pix.xy, Pressure, Deltas);
}
#pragma kernel diffuse_forces
[numthreads(16, 16, 1)]
void diffuse_forces(uint3 pix : SV_DispatchThreadID)
{
	for(int side = 0; side < NumSides; ++side)
		Deltas[at(pix.xy)].deltas[side] = 0;
}

#pragma kernel setup
[numthreads(1, 1, 1)]
void setup(uint3 pix : SV_DispatchThreadID)
{

}
