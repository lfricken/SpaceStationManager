

typedef RWStructuredBuffer<double4> ArrayDelta;
typedef RWStructuredBuffer<double> ArrayDouble;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals ///
ArrayDelta Delta2;
ArrayDelta Delta;

ArrayDouble Mass;

ArrayInt IsBlocked;
ArrayInt DebugData;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;

//////////////
uint NumSides;
float Rate;
int ResolutionX;
float ViscosityGlobal;
float DtGlobal;
float VelocityConservation;

static int2 Offsets[4] =
{
	+int2(1, 0),
	-int2(0, 1),
	-int2(1, 0),
	+int2(0, 1)
};
/////////////

int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

float4 colorGradient(double value, double min, double  middle, double max)
{
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	// TODO extend this to purple and toward white 
	// (white is ok since it will be surrounded by purple)
	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - middle) / (max - middle));
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - min) / (middle - min));
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render
[numthreads(16, 16, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;

	float4 c = float4(1, 0, 1, 1);

	double p = Mass[at(pos)];
	bool isBlocked = IsBlocked[at(pos)];

	if(isBlocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(p, 0, 0.5, 1);
	}

	// dont count the mass in the boundaries
	//if(!isBlocked)
		//InterlockedAdd(DebugData[0], int(p * 1000));

	RenderTexture[pos] = c;

	double deltaSum = 0;
	for(uint side = 0; side < NumSides; ++side)
		deltaSum += Delta[at(pos)][side];

	int2 readPos = int2(pix.x, 1);
	double otherP = Mass[at(readPos)];

	if(otherP > pos.y)
		VelocityMap[pos] = float4(0, 0, 0, 1);// colorGradient(deltaSum, 0, 0.5, 1);
	else
		VelocityMap[pos] = float4(1, 1, 1, 1);
}

// Make the deltas sum to M
void diffuse_deltas(int2 pos, ArrayDouble mass, ArrayDelta deltas)
{
	deltas[at(pos)] *= VelocityConservation;
	double totalMass = mass[at(pos)];
	double deltaSum = 0;
	for(uint side = 0; side < NumSides; ++side)
		deltaSum += deltas[at(pos)][side];

	double modifyPer = (totalMass - deltaSum) / 4.0;
	for(uint side1 = 0; side1 < NumSides; ++side1)
		deltas[at(pos)][side1] += modifyPer;
}
#pragma kernel diffuse_deltas
[numthreads(16, 16, 1)]
void diffuse_deltas(uint3 pix : SV_DispatchThreadID)
{
	if(!IsBlocked[at(pix.xy)])
	{
		diffuse_deltas(pix.xy, Mass, Delta);
	}
}

uint switch_side(uint side)
{
	return (side + (NumSides / 2)) % NumSides;
}

double getContribution(int2 pos, uint fromSide, ArrayDelta deltas)
{

}

void set_mass(int2 pos, ArrayDouble mass, ArrayDelta deltas, ArrayDelta newDeltas)
{
	double contributions = 0;
	for(uint fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		int2 neighbor = Offsets[fromSide] + pos;
		if(IsBlocked[at(neighbor)])
		{
			contributions += deltas[at(pos)][fromSide]; // contribute exactly what we would give them
		}
		else
		{
			int otherSide = switch_side(fromSide); // reverse the side 
			contributions += deltas[at(neighbor)][otherSide]; // get the neighbor contributions to us
		}
		newDeltas[at(pos)] = double4(0, 0, 0, 0);
	}
	mass[at(pos)] = contributions;
}

#pragma kernel set_mass
[numthreads(16, 16, 1)]
void set_mass(uint3 pix : SV_DispatchThreadID)
{
	set_mass(pix.xy, Mass, Delta, Delta2);
}


#pragma kernel copy_all
[numthreads(16, 16, 1)]
void copy_all(uint3 pix : SV_DispatchThreadID)
{
	Delta[at(pix.xy)] = Delta2[at(pix.xy)];
}