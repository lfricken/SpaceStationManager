#pragma enable_d3d11_debug_symbols

RWStructuredBuffer<float> pressure;
RWStructuredBuffer<float> pressureWrite;

RWStructuredBuffer<int> blocked;
RWStructuredBuffer<int> blockedWrite;

RWStructuredBuffer<float> dx;
RWStructuredBuffer<float> dxWrite;

RWStructuredBuffer<float> dy;
RWStructuredBuffer<float> dyWrite;

RWTexture2D<float4> RenderTexture;
int shaderSizeX;

uint at(float2 pos)
{
	return pos.x + pos.y * shaderSizeX;
}
uint at(float x, float y)
{
	return x + y * shaderSizeX;
}
float clampy(float val, int dim)
{
	if(val < 0.5)
		val = 0.5f;
	if(val > dim + 0.5)
		val = dim + 0.5f;
	return val;
}

void set_bnd(int boundary, RWStructuredBuffer<float> tiles)
{
	int dims = shaderSizeX;
	int i;
	for(i = 1; i <= dims; i++)
	{
		tiles[at(0, i)] = (boundary == 1) ? -tiles[at(1, i)] : tiles[at(1, i)];
		tiles[at(dims + 1, i)] = boundary == 1 ? -tiles[at(dims, i)] : tiles[at(dims, i)];
		tiles[at(i, 0)] = boundary == 2 ? -tiles[at(i, 1)] : tiles[at(i, 1)];
		tiles[at(i, dims + 1)] = boundary == 2 ? -tiles[at(i, dims)] : tiles[at(i, dims)];
	}
	tiles[at(0, 0)] = 0.5f * (tiles[at(1, 0)] + tiles[at(0, 1)]);
	tiles[at(0, dims + 1)] = 0.5f * (tiles[at(1, dims + 1)] + tiles[at(0, dims)]);
	tiles[at(dims + 1, 0)] = 0.5f * (tiles[at(dims, 0)] + tiles[at(dims + 1, 1)]);
	tiles[at(dims + 1, dims + 1)] = 0.5f * (tiles[at(dims, dims + 1)] + tiles[at(dims + 1, dims)]);
}

void project(float dims, float posx, float posy, RWStructuredBuffer<float> velX, RWStructuredBuffer<float> velY, RWStructuredBuffer<float> velX0, RWStructuredBuffer<float> velY0)
{
	float h;
	h = 1.0f / dims;

	velY0[at(posx, posy)] = -0.5f * h * (velX[at(posx + 1, posy)] - velX[at(posx - 1, posy)] +
		velY[at(posx, posy + 1)] - velY[at(posx, posy - 1)]);
	velX0[at(posx, posy)] = 0;

	set_bnd(0, velY0); 
	set_bnd(0, velX0);

	velX0[at(posx, posy)] = (velY0[at(posx, posy)] + velX0[at(posx - 1, posy)] + velX0[at(posx + 1, posy)] +
		velX0[at(posx, posy - 1)] + velX0[at(posx, posy + 1)]) / 4;

	set_bnd(0, velX0);


	velX[at(posx, posy)] -= 0.5f * (velX0[at(posx + 1, posy)] - velX0[at(posx - 1, posy)]) / h;
	velY[at(posx, posy)] -= 0.5f * (velX0[at(posx, posy + 1)] - velX0[at(posx, posy - 1)]) / h;

	set_bnd(1, velX); set_bnd(2, velY);
}

void advect(int dim, int x, int y, RWStructuredBuffer<int> blocked, RWStructuredBuffer<float> newPressure, RWStructuredBuffer<float> oldPressure, RWStructuredBuffer<float> velX, RWStructuredBuffer<float> velY)
{
	if(blocked[at(x, y)])
	{
		return;
	}

	float dt = 1;
	int x0, y0, x1, y1;
	float xStart, yStart;
	float s0, t0, s1, t1; // interpolation
	float deltaTime = dt;

	xStart = x - deltaTime * velX[at(x, y)];
	yStart = y - deltaTime * velY[at(x, y)];

	xStart = clampy(xStart, dim);
	x0 = (int)xStart;
	x1 = x0 + 1;

	yStart = clampy(yStart, dim);
	y0 = (int)yStart;
	y1 = y0 + 1;

	s1 = xStart - x0;
	s0 = 1 - s1;
	t1 = yStart - y0;
	t0 = 1 - t1;

	newPressure[at(x, y)] = (s0 * (t0 * oldPressure[at(x0, y0)] + t1 * oldPressure[at(x0, y1)]) + s1 * (t0 * oldPressure[at(x1, y0)] + t1 * oldPressure[at(x1, y1)]));
}
//a
#pragma kernel forces
[numthreads(16, 16, 1)]
void forces(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	advect(shaderSizeX, pos.x, pos.y, blocked, pressureWrite, pressure, dx, dy);
}

#pragma kernel copyToWrite
[numthreads(16, 16, 1)]
void copyToWrite(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	pressureWrite[at(pos)] = pressure[at(pos)];
	blockedWrite[at(pos)] = blocked[at(pos)];
	dxWrite[at(pos)] = dx[at(pos)];
	dyWrite[at(pos)] = dy[at(pos)];
}

#pragma kernel copyToRead
[numthreads(16, 16, 1)]
void copyToRead(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	pressure[at(pos)] = pressureWrite[at(pos)];
	blocked[at(pos)] = blockedWrite[at(pos)];
	dx[at(pos)] = dxWrite[at(pos)];
	dy[at(pos)] = dyWrite[at(pos)];
}

float2 getDiffuse(float2 pos, float2 offset, RWStructuredBuffer<float> old)
{
	int newPos = at(pos + offset);
	float p = old[newPos];
	//int notBlocked = (blocked[newPos] * -1) + 1;

	return float2(p, 1);
}

void diffuse(float2 pos, int boundary, RWStructuredBuffer<float> newPressure, RWStructuredBuffer<float> oldPressure, float viscosity)
{
	float2 np = float2(0, 0);

	// stable density solver
	// x = (x0 + a*(x1 +x2 + x3 + x4)) / (1 + 4 * a);

	np += getDiffuse(pos, float2(1, 0), oldPressure);
	np += getDiffuse(pos, float2(0, 1), oldPressure);
	np += getDiffuse(pos, float2(-1, 0), oldPressure);
	np += getDiffuse(pos, float2(0, -1), oldPressure);

	np.x *= viscosity;
	np.x += oldPressure[at(pos)];
	np.x /= (1 + np.y * viscosity);

	newPressure[at(pos)] = np.x;

	//set_bnd(boundary, newPressure);
}

#pragma kernel diffuseHandle
[numthreads(16, 16, 1)]
void diffuseHandle(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	int isBlocked = blocked[at(pos)];

	// TODO don't just return, calc bounces.
	if(isBlocked)
	{
		return;
	}

	diffuse(pos, 0, pressure, pressureWrite, 1);
}

float4 colorGradient(float value)
{
	float min = 0;
	float middle = 0.5;
	float max = 1;
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - middle) / (max - middle);
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - min) / (middle - min);
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}


#pragma kernel render
[numthreads(16, 16, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	float4 c = float4(1, 0, 1, 1);
	float2 pos = float2(pix.x, pix.y);

	float p = pressure[at(pos)];
	int isBlocked = blocked[at(pos)];

	if(isBlocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(p);
	}

	RenderTexture[pos.xy] = c;
}

