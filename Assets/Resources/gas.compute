
struct DeltaType
{
	double deltas[4];
};

typedef RWStructuredBuffer<DeltaType> ArrayDelta;
typedef RWStructuredBuffer<double> ArrayDouble;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals ///
ArrayDelta DeltaRead;
ArrayDelta Delta;

ArrayDouble PressureRead;
ArrayDouble Pressure;

ArrayInt IsBlocked;
ArrayInt DebugData;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;

//////////////
int NumSides;
float Rate;
int ResolutionX;
float ViscosityGlobal;
float DtGlobal;

static int2 Offsets[4] =
{
	+int2(1, 0),
	-int2(0, 1),
	-int2(1, 0),
	+int2(0, 1)
};
/////////////

int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

float4 colorGradient(double value, double min, double  middle, double max)
{
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	// TODO extend this to purple and toward white 
	// (white is ok since it will be surrounded by purple)
	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - middle) / (max - middle));
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - min) / (middle - min));
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render
[numthreads(16, 16, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;

	float4 c = float4(1, 0, 1, 1);

	double p = Pressure[at(pos)];
	bool isBlocked = IsBlocked[at(pos)];

	if(isBlocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(p, 0, 10, 20);
	}

	// dont count the pressure in the boundaries
	if(!isBlocked)
		InterlockedAdd(DebugData[0], int(p * 1000));

	RenderTexture[pos] = c;

	double deltaSum = 0;
	for(int side = 0; side < NumSides; ++side)
		deltaSum += Delta[at(pos)].deltas[side];

	VelocityMap[pos] = colorGradient(deltaSum, 0, 5, 10);
}

////////////
/// swap ///
////////////
#pragma kernel copy_all
[numthreads(16, 16, 1)]
void copy_all(uint3 pix : SV_DispatchThreadID)
{
	//swap_core(pix.xy, pressure, pressureRead);
}


void calc_forces(int2 pos, ArrayDouble p, ArrayDelta d)
{
	for(int side = 0; side < NumSides; ++side)
	{
		double pressure = p[at(pos)];
		int2 offset = Offsets[side];
		double otherPressure = p[at(pos + offset)];
		double difference = pressure - otherPressure;
		d[at(pos)].deltas[side] += max(0, difference * Rate);
	}
	//DebugData[0] = 0;
}
#pragma kernel calc_diffusion_forces
[numthreads(16, 16, 1)]
void calc_diffusion_forces(uint3 pix : SV_DispatchThreadID)
{
	calc_forces(pix.xy, Pressure, Delta);
}

void move_gas(int2 pos, ArrayDouble p, ArrayDouble p0, ArrayDelta d)
{

}

#pragma kernel apply_diffusion_forces
[numthreads(16, 16, 1)]
void apply_diffusion_forces(uint3 pix : SV_DispatchThreadID)
{
	move_gas(pix.xy, Pressure, PressureRead, Delta);
}


#pragma kernel diffuse_forces
[numthreads(16, 16, 1)]
void diffuse_forces(uint3 pix : SV_DispatchThreadID)
{
	for(int side = 0; side < NumSides; ++side)
		Delta[at(pix.xy)].deltas[side] = 0;
}
