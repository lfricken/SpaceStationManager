#pragma enable_d3d11_debug_symbols

typedef RWStructuredBuffer<float> Array;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals //
Array pressureRead;
Array pressure;

Array dxRead;
Array dx;

Array dyRead;
Array dy;

ArrayInt blocked;
ArrayInt debug;

RWTexture2D<float4> RenderTexture;

/////////////
int shaderSizeX;
float viscosityGlobal;
float dtGlobal;

int totalMass1000;
/////////////

uint at(float2 pos)
{
	return pos.x + pos.y * shaderSizeX;
}
uint at(float x, float y)
{
	return x + y * shaderSizeX;
}

void swap_core(float2 pix, Array a, Array b)
{
	float temp = a[at(pix)];
	a[at(pix)] = b[at(pix)];
	b[at(pix)] = temp;
}

float clampy(float val, int dim)
{
	if(val < 0.5)
		val = 0.5f;
	if(val > dim + 0.5)
		val = dim + 0.5f;
	return val;
}

void set_bnd(float2 pos, int b, Array x) // 
{
	int dims = shaderSizeX - 2;
	int max = shaderSizeX - 1;
	//int dims = shaderSizeX - 2;
	//int innerEdgeLow = 1;
	//int innerEdgeHigh = shaderSizeX - 2;

	//int outerEdgeLow = 0;
	//int outerEdgeHigh = shaderSizeX - 1;

	float2 offset = float2(0, 0);

	if(pos.x == 0)
	{
		//offset.x = 1;
		x[at(pos)] = b == 1 ? -x[at(1, pos.y)] : x[at(1, pos.y)];
	}
	if(pos.x == max)
	{
		//offset.x = -1;
		x[at(dims + 1, pos.y)] = b == 1 ? -x[at(dims, pos.y)] : x[at(dims, pos.y)];
	}
	if(pos.y == 0)
	{
		//offset.y = 1;
		x[at(pos.x, 0)] = b == 2 ? -x[at(pos.x, 1)] : x[at(pos.x, 1)];
	}
	if(pos.y == max)
	{
		//offset.y = -1;
		x[at(pos.x, dims + 1)] = b == 2 ? -x[at(pos.x, dims)] : x[at(pos.x, dims)];
	}

	//x[at(pos)] = x[at(pos + offset)];

	if((pos.x == 0 || pos.x == shaderSizeX - 1) && (pos.y == 0 || pos.y == shaderSizeX - 1))
	{
		x[at(0, 0)] = 0.5*(x[at(1, 0)] + x[at(0, 1)]);
		x[at(0, dims + 1)] = 0.5*(x[at(1, dims + 1)] + x[at(0, dims)]);
		x[at(dims + 1, 0)] = 0.5*(x[at(dims, 0)] + x[at(dims + 1, 1)]);
		x[at(dims + 1, dims + 1)] = 0.5*(x[at(dims, dims + 1)] + x[at(dims + 1, dims)]);
	}
	//x[at(pos)] = 1;
}

void advect_core(float2 pos, int dim, int boundary, Array value, Array valueRead, Array velX, Array velY, float dt)
{
	int x0, y0, x1, y1;
	float xStart, yStart;
	float s0, t0, s1, t1; // interpolations
	float deltaTime = dt;

	xStart = pos.x - deltaTime * velX[at(pos.x, pos.y)];
	yStart = pos.y - deltaTime * velY[at(pos.x, pos.y)];

	xStart = clampy(xStart, dim);
	x0 = (int)xStart;
	x1 = x0 + 1;

	yStart = clampy(yStart, dim);
	y0 = (int)yStart;
	y1 = y0 + 1;

	s1 = xStart - x0;
	s0 = 1 - s1;
	t1 = yStart - y0;
	t0 = 1 - t1;

	value[at(pos.x, pos.y)] = (s0 * (t0 * valueRead[at(x0, y0)] + t1 * valueRead[at(x0, y1)]) + s1 * (t0 * valueRead[at(x1, y0)] + t1 * valueRead[at(x1, y1)]));

	set_bnd(pos, boundary, value);
}

void project_start_core(float2 pos, float dims, Array u, Array v, Array p, Array div)
{
	float h = float(1) / dims;

	div[at(pos.x, pos.y)] = -0.5f * h * (u[at(pos.x + 1, pos.y)] - u[at(pos.x - 1, pos.y)] +
		v[at(pos.x, pos.y + 1)] - v[at(pos.x, pos.y - 1)]);
	p[at(pos.x, pos.y)] = 0;

	set_bnd(pos, 0, div); set_bnd(pos, 0, p);
}

void project_loop_core(float2 pos, float dims, Array u, Array v, Array p, Array div)
{
	float h = float(1) / dims;

	p[at(pos.x, pos.y)] = (div[at(pos.x, pos.y)] + p[at(pos.x - 1, pos.y)] + p[at(pos.x + 1, pos.y)] +
		p[at(pos.x, pos.y - 1)] + p[at(pos.x, pos.y + 1)]) / 4;

	set_bnd(pos, 0, p);
}

void project_end_core(float2 pos, float dims, Array u, Array v, Array p, Array div)
{
	float h = float(1) / dims;

	u[at(pos.x, pos.y)] -= 0.5f * (p[at(pos.x + 1, pos.y)] - p[at(pos.x - 1, pos.y)]) / h;
	v[at(pos.x, pos.y)] -= 0.5f * (p[at(pos.x, pos.y + 1)] - p[at(pos.x, pos.y - 1)]) / h;

	set_bnd(pos, 1, u); set_bnd(pos, 2, v);
}

float2 getDiffuse(float2 pos, float2 offset, Array newPressure)
{
	int newPos = at(pos + offset);
	float p = newPressure[newPos];
	//int notBlocked = (blocked[newPos] * -1) + 1;

	return float2(p, 0);
}

bool shouldSkip(float2 pos)
{
	int max = shaderSizeX - 1;
	if(pos.x == 0)
		return true;
	if(pos.x == max)
		return true;
	if(pos.y == 0)
		return true;
	if(pos.y == max)
		return true;
	return false;
}

void diffuse_loop(float2 pos, int boundary, Array newPressure, Array oldPressure, float viscosity, float deltaTime)
{
	if(shouldSkip(pos))
		return;
	//if(blocked[at(pos)])//
	//	return;

	float2 np = float2(0, 0);

	float a = viscosity * deltaTime;

	np += getDiffuse(pos, float2(1, 0), newPressure);
	np += getDiffuse(pos, float2(0, 1), newPressure);
	np += getDiffuse(pos, float2(-1, 0), newPressure);
	np += getDiffuse(pos, float2(0, -1), newPressure);

	np.x *= a;
	np.x += oldPressure[at(pos)];
	np.x /= (1 + 4 * a);

	newPressure[at(pos)] = np.x;

	set_bnd(pos, boundary, newPressure);
	debug[0] = 0;
}

float4 colorGradient(float value)
{
	float min = 0;
	float middle = 0.5;
	float max = 1;
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	// TODO extend this to purple
	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - middle) / (max - middle);
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - min) / (middle - min);
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render_pressure
[numthreads(16, 16, 1)]
void render_pressure(uint3 pix : SV_DispatchThreadID)
{
	//if(pix.x == 0 || pix.y == 0)
	//	return;

	float2 pos = pix.xy;

	float4 c = float4(1, 0, 1, 1);

	float p = pressure[at(pos)];
	bool isBlocked = blocked[at(pos)];

	if(isBlocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(p);
	}

	RenderTexture[pos] = c;

	InterlockedAdd(debug[0], p * 1000);
}

///////////////
/// diffuse ///
///////////////
#pragma kernel diffuse_pressure
[numthreads(16, 16, 1)]
void diffuse_pressure(uint3 pix : SV_DispatchThreadID)
{
	diffuse_loop(pix.xy, 0, pressure, pressureRead, viscosityGlobal, dtGlobal);
}

#pragma kernel diffuse_dx
[numthreads(16, 16, 1)]
void diffuse_dx(uint3 pix : SV_DispatchThreadID)
{
	diffuse_loop(pix.xy, 1, dx, dxRead, viscosityGlobal, dtGlobal);
}

#pragma kernel diffuse_dy
[numthreads(16, 16, 1)]
void diffuse_dy(uint3 pix : SV_DispatchThreadID)
{
	diffuse_loop(pix.xy, 2, dy, dyRead, viscosityGlobal, dtGlobal);
}

//////////////
/// advect ///
//////////////
#pragma kernel advect_pressure
[numthreads(16, 16, 1)]
void advect_pressure(uint3 pix : SV_DispatchThreadID)
{
	//advect ( N, 0, x, x0, u, v, dt );
	advect_core(pix.xy, shaderSizeX, 0, pressure, pressureRead, dx, dy, dtGlobal);
}

#pragma kernel advect_dx
[numthreads(16, 16, 1)]
void advect_dx(uint3 pix : SV_DispatchThreadID)
{
	//advect ( N, 1, u, u0, u0, v0, dt ); 
	advect_core(pix.xy, shaderSizeX, 1, dx, dxRead, dxRead, dyRead, dtGlobal);
}

#pragma kernel project_end
[numthreads(16, 16, 1)]
void advect_dy(uint3 pix : SV_DispatchThreadID)
{
	//advect ( N, 2, v, v0, u0, v0, dt );
	advect_core(pix.xy, shaderSizeX, 2, dy, dyRead, dxRead, dyRead, dtGlobal);
}

///////////////
/// project ///
///////////////
#pragma kernel project_start
[numthreads(16, 16, 1)]
void project_start(uint3 pix : SV_DispatchThreadID)
{
	project_start_core(pix.xy, shaderSizeX, dx, dy, dxRead, dyRead);
}

#pragma kernel project_loop
[numthreads(16, 16, 1)]
void project_loop(uint3 pix : SV_DispatchThreadID)
{
	project_loop_core(pix.xy, shaderSizeX, dx, dy, dxRead, dyRead);
}

#pragma kernel project_end
[numthreads(16, 16, 1)]
void project_end(uint3 pix : SV_DispatchThreadID)
{
	project_end_core(pix.xy, shaderSizeX, dx, dy, dxRead, dyRead);
}

///////////////
/// set_bnd ///
///////////////
#pragma kernel set_bnd_diffuse_pressure
[numthreads(16, 16, 1)]
void set_bnd_diffuse_pressure(uint3 pix : SV_DispatchThreadID)
{
	set_bnd(pix.xy, 0, pressure);
	set_bnd(pix.xy, 0, pressureRead);
}

////////////
/// swap ///
////////////
#pragma kernel swap_dx
[numthreads(16, 16, 1)]
void swap_dx(uint3 pix : SV_DispatchThreadID)
{
	swap_core(pix.xy, dx, dxRead);
}

#pragma kernel swap_dy
[numthreads(16, 16, 1)]
void swap_dy(uint3 pix : SV_DispatchThreadID)
{
	swap_core(pix.xy, dy, dyRead);
}

#pragma kernel swap_pressure
[numthreads(16, 16, 1)]
void swap_pressure(uint3 pix : SV_DispatchThreadID)
{
	swap_core(pix.xy, pressure, pressureRead);
}