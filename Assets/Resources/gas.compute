#pragma enable_d3d11_debug_symbols

struct PressureTile
{
	float pressure;
	int blocked;

	float dx;
	float dy;
};
uint at(float2 pos)
{
	return pos.x + pos.y * 64;
}
uint at(float x, float y)
{
	return x + y * 64;
}
float clamp(float val, int dim)
{
	if(val < 0.5)
		val = 0.5f;
	if(val > dim + 0.5)
		val = dim + 0.5f;
	return val;
}
RWStructuredBuffer<PressureTile> PressureTilesWrite;
RWStructuredBuffer<PressureTile> PressureTiles;

RWTexture2D<float4> RenderTexture;

//
void advect(int dim, int x, int y)
{
	if(PressureTiles[at(x, y)].blocked)
	{
		return;
	}

	float dt = 0.1;
	int x0, y0, x1, y1;
	float xStart, yStart;
	float s0, t0, s1, t1; // interpolation
	float deltaTime = dt;

	xStart = x - deltaTime * PressureTiles[at(x, y)].dx;
	yStart = y - deltaTime * PressureTiles[at(x, y)].dy;

	xStart = clamp(xStart, dim);
	x0 = (int)xStart;
	x1 = x0 + 1;

	yStart = clamp(yStart, dim);
	y0 = (int)yStart;
	y1 = y0 + 1;

	s1 = xStart - x0;
	s0 = 1 - s1;
	t1 = yStart - y0;
	t0 = 1 - t1;


	PressureTilesWrite[at(x, y)].pressure = (s0 * (t0 * PressureTiles[at(x0, y0)].pressure + t1 * PressureTiles[at(x0, y1)].pressure) + s1 * (t0 * PressureTiles[at(x1, y0)].pressure + t1 * PressureTiles[at(x1, y1)].pressure));
}
//a
#pragma kernel forces
[numthreads(16, 16, 1)]
void forces(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	advect(64, pos.x, pos.y);
}

#pragma kernel copyToWrite
[numthreads(16, 16, 1)]
void copyToWrite(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	PressureTilesWrite[at(pos)] = PressureTiles[at(pos)];
}

#pragma kernel copyToRead
[numthreads(16, 16, 1)]
void copyToRead(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	PressureTiles[at(pos)] = PressureTilesWrite[at(pos)];
}

float2 getDiffuse(float2 pos, float2 offset)
{
	PressureTile tile = PressureTilesWrite[at(pos + offset)];

	float contrib = tile.pressure;

	return float2(contrib, (tile.blocked * -1) + 1);
}

#pragma kernel diffuse
[numthreads(16, 16, 1)]
void diffuse(uint3 pix : SV_DispatchThreadID)
{
	float2 pos = float2(pix.x, pix.y);
	PressureTile tile = PressureTiles[at(pos)];

	// TODO don't just return, calc bounces!
	if(tile.blocked)
	{
		return;
	}

	float2 newPressure = float2(0, 0);

	// stable density solver
	// x = (x0 + a*(x1 +x2 + x3 + x4)) / (1 + 4 * a);//
	float diffusion = 1;

	newPressure += getDiffuse(pos, float2(1, 0));
	newPressure += getDiffuse(pos, float2(0, 1));
	newPressure += getDiffuse(pos, float2(-1, 0));
	newPressure += getDiffuse(pos, float2(0, -1));

	newPressure.x *= diffusion;
	newPressure.x += tile.pressure;
	newPressure.x /= (1 + newPressure.y * diffusion);

	PressureTilesWrite[at(pos)].pressure = newPressure.x;
}

float4 colorGradient(float value)
{
	float min = 0;
	float middle = 0.5;
	float max = 1;
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - middle) / (max - middle);
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = (value - min) / (middle - min);
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

#pragma kernel render
[numthreads(16, 16, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	float4 c = float4(1, 0, 1, 1);
	float2 pos = float2(pix.x, pix.y);

	PressureTile tile = PressureTiles[at(pos)];

	if(tile.blocked)
	{
		c.rgb = 0;
	}
	else
	{
		c = colorGradient(tile.pressure);
	}

	RenderTexture[pos.xy] = c;
}

