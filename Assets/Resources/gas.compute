

typedef RWStructuredBuffer<double4> ArrayDelta;
typedef RWStructuredBuffer<double> ArrayDouble;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals ///
ArrayDelta Delta2;
ArrayDelta Delta;

ArrayDouble Mass;

ArrayInt IsBlocked;
ArrayInt DebugData;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;
RWTexture2D<float4> FakeMap;

//////////////
uint NumSides;
int ResolutionX;
float VelocityConservation;
float MassCollisionDeflectFraction;

static int2 Offsets[4] =
{
	+int2(1, 0),
	-int2(0, 1),
	-int2(1, 0),
	+int2(0, 1)
};
/////////////


uint switch_side(uint side)
{
	return (side + (NumSides / 2)) % NumSides;
}
uint rotate_side(uint side)
{
	return side % NumSides;
}
int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

float4 colorGradient(double value, double min, double  middle, double max)
{
	float4 color = float4(0, 0, 0, 1);

	if(value == 0)
	{
		return float4(1, 1, 1, 1);
	}

	// TODO extend this to purple and toward white 
	// (white is ok since it will be surrounded by purple)
	if(value > max)
	{
		color.r = 1;
	}
	else if(value > middle)
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - middle) / (max - middle));
		color.r = between;
		color.g = 1 - between;
	}
	else
	{
		// bound the value to [min, max] as [0, 1]
		float between = float((value - min) / (middle - min));
		color.g = between;
		color.b = 1 - between;
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render
[numthreads(8, 8, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;
	double p = Mass[at(pos)];
	bool isBlocked = IsBlocked[at(pos)];


	// fake map
	int2 readPos = int2(pix.x, 1);
	double otherP = Mass[at(readPos)] * 30;
	if(otherP > pos.y)
		FakeMap[pos] = float4(0, 0, 0, 1);
	else
		FakeMap[pos] = float4(1, 1, 1, 1);

	if(isBlocked)
	{
		FakeMap[pos] = float4(1, 1, 1, 1);
		RenderTexture[pos] = VelocityMap[pos] = float4(0, 0, 0, 1);
		return;
	}

	// pressure map
	RenderTexture[pos] = colorGradient(p, 0, 0.5, 1);

	// delta map
	double deltaSum = 0;
	for(uint side = 0; side < (NumSides / 2); ++side)
	{
		uint otherSide = switch_side(side);
		deltaSum += abs(Delta[at(pos)][side] - Delta[at(pos)][otherSide]);
	}
	VelocityMap[pos] = colorGradient(deltaSum, 0.0, 0.2, 0.4);
}

// Make the deltas sum to M
void diffuse_deltas(int2 pos, ArrayDouble mass, ArrayDelta deltas)
{
	deltas[at(pos)] *= VelocityConservation;
	double totalMass = mass[at(pos)];
	double deltaSum = 0;
	for(uint side = 0; side < NumSides; ++side)
		deltaSum += deltas[at(pos)][side];

	double modifyPer = (totalMass - deltaSum) / NumSides;
	for(uint side1 = 0; side1 < NumSides; ++side1)
		deltas[at(pos)][side1] += modifyPer;
}
#pragma kernel diffuse_deltas
[numthreads(8, 8, 1)]
void diffuse_deltas(uint3 pix : SV_DispatchThreadID)
{
	if(!IsBlocked[at(pix.xy)])
	{
		diffuse_deltas(pix.xy, Mass, Delta);
	}
}

void set_mass(int2 pos, ArrayDouble mass, ArrayDelta deltas, ArrayDelta newDeltas)
{
	for(uint fromSide2 = 0; fromSide2 < NumSides; ++fromSide2)
	{
		newDeltas[at(pos)][fromSide2] = 0;
	}
	double totalContributions = 0;
	for(uint fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		int otherSide = switch_side(fromSide); // reverse the side 
		int2 neighbor = Offsets[fromSide] + pos;
		double thisMassContrib = 0;
		double thisDeltaContrib = 0;
		if(IsBlocked[at(neighbor)])
		{
			double bounceConservation = 1.0; // delta loss from bouncing off wall
			thisMassContrib = deltas[at(pos)][fromSide]; // contribute exactly what we would give them
			thisDeltaContrib = bounceConservation * thisMassContrib;
		}
		else
		{
			thisMassContrib = deltas[at(neighbor)][otherSide]; // get the neighbor contributions to us.
			thisDeltaContrib = thisMassContrib;
		}
		newDeltas[at(pos)][otherSide] = thisDeltaContrib; // the gas will flow to the opposite tile it came from
		totalContributions += thisMassContrib;
	}

	// move deltas sideways
	for(uint fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		int otherSide = switch_side(fromSide); // reverse the side 
		double val1 = newDeltas[at(pos)][fromSide];
		double val2 = newDeltas[at(pos)][otherSide];

		double halfMass = min(val1, val2) / MassCollisionDeflectFraction;

		newDeltas[at(pos)][fromSide] -= halfMass;
		newDeltas[at(pos)][otherSide] -= halfMass;

		newDeltas[at(pos)][rotate_side(fromSide + 1)] += halfMass;
		newDeltas[at(pos)][rotate_side(fromSide - 1)] += halfMass;
	}
	mass[at(pos)] = totalContributions;
}

#pragma kernel set_mass
[numthreads(8, 8, 1)]
void set_mass(uint3 pix : SV_DispatchThreadID)
{
	set_mass(pix.xy, Mass, Delta, Delta2);
}


#pragma kernel copy_all
[numthreads(8, 8, 1)]
void copy_all(uint3 pix : SV_DispatchThreadID)
{
	Delta[at(pix.xy)] = Delta2[at(pix.xy)];
}