

typedef float2 VelType;
typedef VelType PosType;

struct Particle
{
	PosType pos;
	VelType vel;
};

typedef RWStructuredBuffer<Particle> ArrayOxygen;
typedef RWStructuredBuffer<int> ArrayInt;

ArrayOxygen Oxygens;
ArrayInt Mass;
ArrayInt IsBlocked;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;
RWTexture2D<float4> FakeMap;

//////////////
uint ParticlesPerPoint;
int ResolutionX;

float MaxPressureRender; // max value for color map
float MaxDeltaRender; // max value for color map


// Index a 1D array as a 2D array.
int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

int getPixelFor(float2 pos)
{
	return int(pos.x) + int(pos.y) * ResolutionX;
}

int getParticle(int2 pos, int particlesPerPoint, int offset)
{
	return (at(pos) * particlesPerPoint) + offset;
}

// Bound value to [min, max] as [0, 1]
float normalize(float min, float max, float value)
{
	return float((value - min) / (max - min));
}

// Compute a false color map
float4 colorGradient(float value, float min, float max)
{
	float4 color = float4(0, 0, 0, 1);

	float inc = (max - min) / 6.0;

	float low = min + inc;
	float middle = low + inc;
	float high = middle + inc;
	float ultra = high + inc;

	float darkPurple = 0.2;

	if(value >= max) // dark purple
	{
		color = float4(darkPurple, 0, darkPurple, 1);
	}
	else if(value >= ultra) // purple to dark purple
	{
		float between = normalize(ultra, max, value);
		color.rb = 1 - (1 - darkPurple) * between;
	}
	else if(value >= high) // red to purple
	{
		float between = normalize(high, ultra, value);
		color.r = 1;
		color.b = between;
	}
	else if(value >= middle) // green to red
	{
		float between = normalize(middle, high, value);
		color.r = between;
		color.g = 1 - between;
	}
	else if(value >= low) // blue to green
	{
		float between = normalize(low, middle, value);
		color.g = between;
		color.b = 1 - between;
	}
	else if(value >= min) // white to blue
	{
		float between = normalize(min, low, value);
		color.r = 1 - between;
		color.g = 1 - between;
		color.b = 1;
	}
	else
	{
		color = float4(1, 1, 1, 1);
	}

	return color;
}

//////////////
/// render //
//////////////
#pragma kernel render
[numthreads(8, 8, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;
	double p = float(Mass[at(pos)]) / 20.0;
	bool isBlocked = IsBlocked[at(pos)];


	// fake map
	int2 readPos = int2(pix.x, 1);
	double otherP = Mass[at(readPos)] * 30;
	if(otherP > pos.y)
		FakeMap[pos] = float4(0, 0, 0, 1);
	else
		FakeMap[pos] = float4(1, 1, 1, 1);

	if(isBlocked)
	{
		FakeMap[pos] = float4(1, 1, 1, 1);
		RenderTexture[pos] = VelocityMap[pos] = float4(0, 0, 0, 1);
		return;
	}

	// pressure map
	RenderTexture[pos] = colorGradient((float)p, 0, MaxPressureRender);

	// delta map
	VelocityMap[pos] = colorGradient((float)1, 0.0, MaxDeltaRender);
}

// Reduce Deltas and then make the deltas sum to total mass again to diffuse velocity
Particle apply_step2(Particle part)
{
	PosType currentPos = part.pos;
	PosType nextPos = currentPos + part.vel;
	part.pos = nextPos;

	if(IsBlocked[getPixelFor(nextPos)])
	{
		part.vel = -part.vel;
		part.vel.x += 0.1;
		part.vel.y -= 0.1;
		part.pos = currentPos;
	}

	InterlockedAdd(Mass[getPixelFor(currentPos)], -1);
	InterlockedAdd(Mass[getPixelFor(nextPos)], 1);

	return part;
}

#pragma kernel apply_step
[numthreads(8, 8, 1)]
void apply_step(uint3 pix : SV_DispatchThreadID)
{
	for(uint i = 0; i < ParticlesPerPoint; ++i)
	{
		Particle particle = Oxygens[getParticle(pix.xy, ParticlesPerPoint, i)];
		Oxygens[getParticle(pix.xy, ParticlesPerPoint, i)] = apply_step2(particle);
	}
}

void inits(Particle part)
{
	InterlockedAdd(Mass[getPixelFor(part.pos)], 1);
}

#pragma kernel init_values
[numthreads(8, 8, 1)]
void init_values(uint3 pix : SV_DispatchThreadID)
{
	for(uint i = 0; i < ParticlesPerPoint; ++i)
	{
		Particle particle = Oxygens[getParticle(pix.xy, ParticlesPerPoint, i)];
		inits(particle);
	}
}
