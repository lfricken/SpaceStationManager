
// TODO Convert to use floats
// TODO improve to handle heat and composition
// blocked tiles should have heat information as well


////// Textures

//// Gas (heat cap and conductivity calculated based on masses)
// Temperature
// O2
// CO2
// CO
// Methane

//// Heat Texture
// Temperature
// HeatCap
// Conductivity
// Mass



//// heat transfer
// gas and building
// temperatures are read only
// compute +/- deltas for up down and left right (need two textures) y=2x-2*root(x)
// apply heat energy


//// gas transfer
// gas only
// compute deltas: 2 textures, 2 floats per pixel




//// heat
// each pairwise tile, calculate the heat transfer between them and write to 

// temp
struct HotMass
{
	float Energy;
	float HeatCapacity;
	float Conduct;
	float Mass;
};
float geoMean(float a, float b)
{
	return sqrt(a * b);
}
float deltaQ(HotMass a, HotMass b)
{
	float k = geoMean(a.Cond, b.Cond);
	float dTemp = b.Temp - a.Temp;
	float dT = 0.1;
	return k * dTemp * dT;
}
bool newTemps(float dQ, HotMass a, HotMass b)
{

}

float findDelta(HotMass a, HotMass b)
{
	dQ = deltaQ(a, b);

}

// gas
void graph(float diff, out float dA, out float dB)
{
	float aIn = 0.25f * (diff - 1);
	float bIn = 0.25f * (diff + 1);

	dA = aIn * aIn * aIn * aIn * 4;
	dB = bIn * bIn * bIn * bIn * 4;
}
void findDelta(float a, float b, out float dA, out float dB)
{
	float total = a + b;
	float aP = a / total;
	float bP = b / total;

	float diff = (bP - aP);// [1, -1];

	graph(diff, dA, dB);
	dA *= a;
	dB *= b;
}


// equal percentages are assumed



// render

// compute gas deltas based on mass difference
// compute new gas temperatures






typedef RWStructuredBuffer<double4> ArrayDelta;
typedef RWStructuredBuffer<double> ArrayDouble;
typedef RWStructuredBuffer<int> ArrayInt;

// Globals ///
ArrayDelta Delta2;
ArrayDelta Delta;

// mass needs to include temperature (float), and composition
ArrayDouble Mass;
ArrayDouble AddRemoveMass;

ArrayInt IsBlocked;
ArrayInt DebugData;

RWTexture2D<float4> RenderTexture;
RWTexture2D<float4> VelocityMap;
RWTexture2D<float4> FakeMap;

//////////////
uint NumSides;
int ResolutionX;
float VelocityConservation; // each tick, how much directional velocity gets lost
float MassCollisionDeflectFraction; // what fraction of the smaller colliding amount will get squished sideways
float WaveSpread; // what fraction of mass will move to adjacent cells (maintaining delta direction)

float MaxPressureRender; // max value for color map
float MaxDeltaRender; // max value for color map

static int2 Offsets[4] =
{
	+int2(1, 0), // right
	-int2(0, 1), // down
	-int2(1, 0), // left
	+int2(0, 1)  // up
};
/////////////

// Find the opposite side
uint switch_side(uint side)
{
	return (side + (NumSides / 2)) % NumSides;
}
// Just make sure the passed value resolves to a valid side value. (passing in side+1 returns the next side to the left)
uint rotate_side(uint side)
{
	return side % NumSides;
}
// Index a 1D array as a 2D array.
int at(int2 pos)
{
	return pos.x + pos.y * ResolutionX;
}

// Bound value to [min, max] as [0, 1]
float normalize(float min, float max, float value)
{
	return float((value - min) / (max - min));
}

// Compute a false color map
float4 colorGradient(float value, float min, float max)
{
	float4 color = float4(0, 0, 0, 1);

	float inc = (max - min) / 6.0;

	float low = min + inc;
	float middle = low + inc;
	float high = middle + inc;
	float ultra = high + inc;

	float darkPurple = 0.2;

	if(value >= max) // dark purple
	{
		color = float4(darkPurple, 0, darkPurple, 1);
	}
	else if(value >= ultra) // purple to dark purple
	{
		float between = normalize(ultra, max, value);
		color.rb = 1 - (1 - darkPurple) * between;
	}
	else if(value >= high) // red to purple
	{
		float between = normalize(high, ultra, value);
		color.r = 1;
		color.b = between;
	}
	else if(value >= middle) // green to red
	{
		float between = normalize(middle, high, value);
		color.r = between;
		color.g = 1 - between;
	}
	else if(value >= low) // blue to green
	{
		float between = normalize(low, middle, value);
		color.g = between;
		color.b = 1 - between;
	}
	else if(value >= min) // white to blue
	{
		float between = normalize(min, low, value);
		color.r = 1 - between;
		color.g = 1 - between;
		color.b = 1;
	}
	else
	{
		color = float4(1, 1, 1, 1);
	}

	return color;
}

//////////////
/// render ///
//////////////
#pragma kernel render
[numthreads(8, 8, 1)]
void render(uint3 pix : SV_DispatchThreadID)
{
	int2 pos = pix.xy;
	double p = Mass[at(pos)];
	bool isBlocked = IsBlocked[at(pos)];


	// fake map
	int2 readPos = int2(pix.x, 1);
	double otherP = Mass[at(readPos)] * 30;
	if(otherP > pos.y)
		FakeMap[pos] = float4(0, 0, 0, 1);
	else
		FakeMap[pos] = float4(1, 1, 1, 1);

	if(isBlocked)
	{
		FakeMap[pos] = float4(1, 1, 1, 1);
		RenderTexture[pos] = VelocityMap[pos] = float4(0, 0, 0, 1);
		return;
	}

	// pressure map
	RenderTexture[pos] = colorGradient((float)p, 0, MaxPressureRender);

	// delta map
	double deltaSum = 0;
	for(uint side = 0; side < (NumSides / 2); ++side)
	{
		uint otherSide = switch_side(side);
		deltaSum += abs(Delta[at(pos)][side] - Delta[at(pos)][otherSide]);
	}
	VelocityMap[pos] = colorGradient((float)deltaSum, 0.0, MaxDeltaRender);
}

// Reduce Deltas and then make the deltas sum to total mass again to diffuse velocity
void diffuse_deltas(int2 pos, ArrayDouble mass, ArrayDelta deltas)
{
	deltas[at(pos)] *= VelocityConservation;
	double totalMass = mass[at(pos)];
	double deltaSum = 0;
	for(uint side = 0; side < NumSides; ++side)
		deltaSum += deltas[at(pos)][side];

	double modifyPer = (totalMass - deltaSum) / NumSides;
	for(uint side1 = 0; side1 < NumSides; ++side1)
		deltas[at(pos)][side1] += modifyPer;
}
#pragma kernel diffuse_deltas
[numthreads(8, 8, 1)]
void diffuse_deltas(uint3 pix : SV_DispatchThreadID)
{
	if(!IsBlocked[at(pix.xy)])
	{
		diffuse_deltas(pix.xy, Mass, Delta);
	}
}

// actually move mass deltas to new locations
void set_mass(int2 pos, ArrayDouble mass, ArrayDelta deltas, ArrayDelta newDeltas)
{
	uint fromSide = 0;
	for(fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		newDeltas[at(pos)][fromSide] = 0;
	}
	double totalContributions = 0;
	// for each side, find the contributions and compute new total mass and deltas
	for(fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		int otherSide = switch_side(fromSide);
		int2 neighbor = Offsets[fromSide] + pos;
		double thisMassContrib = 0;
		if(IsBlocked[at(neighbor)])
			thisMassContrib = deltas[at(pos)][fromSide]; // contribute exactly what we would give them
		else
			thisMassContrib = deltas[at(neighbor)][otherSide]; // get the gas the neighbor sends to us

		newDeltas[at(pos)][otherSide] = thisMassContrib; // the gas will flow to the opposite delta it came from
		totalContributions += thisMassContrib;
	}

	// rotate deltas based on collision with other gas (when two opposing gasses collide they squish and move sideways)
	for(fromSide = 0; fromSide < NumSides; ++fromSide)
	{
		int otherSide = switch_side(fromSide); // reverse the side 
		double val1 = newDeltas[at(pos)][fromSide];
		double val2 = newDeltas[at(pos)][otherSide];

		double halfMass = min(val1, val2) / MassCollisionDeflectFraction;

		newDeltas[at(pos)][fromSide] -= halfMass;
		newDeltas[at(pos)][otherSide] -= halfMass;

		newDeltas[at(pos)][rotate_side(fromSide + 1)] += halfMass;
		newDeltas[at(pos)][rotate_side(fromSide - 1)] += halfMass;
	}


	totalContributions += AddRemoveMass[at(pos)];
	totalContributions = max(0, totalContributions);

	mass[at(pos)] = totalContributions;
}

#pragma kernel set_mass
[numthreads(8, 8, 1)]
void set_mass(uint3 pix : SV_DispatchThreadID)
{
	set_mass(pix.xy, Mass, Delta, Delta2);
}

// move deltas sideways like a wave spreading out
void share_deltas(int2 pos, ArrayDouble mass, ArrayDelta deltas, ArrayDelta newDeltas)
{
	float WaveSpread = 0.1;
	newDeltas[at(pos)] = deltas[at(pos)];

	for(uint side = 0; side < NumSides; ++side)
	{
		double massLeave = deltas[at(pos)][side] * WaveSpread;
		newDeltas[at(pos)][side] -= massLeave * 2;

		int2 neighborLeft = Offsets[rotate_side(side + 1)] + pos;
		int2 neighborRight = Offsets[rotate_side(side - 1)] + pos;

		if(IsBlocked[at(neighborLeft)])
			newDeltas[at(pos)][side] += massLeave;
		else
			newDeltas[at(pos)][side] += deltas[at(neighborLeft)][side] * WaveSpread;// get left neighbor

		if(IsBlocked[at(neighborRight)])
			newDeltas[at(pos)][side] += massLeave;
		else
			newDeltas[at(pos)][side] += deltas[at(neighborRight)][side] * WaveSpread;// get left neighbor
	}
}

#pragma kernel share_deltas
[numthreads(8, 8, 1)]
void share_deltas(uint3 pix : SV_DispatchThreadID)
{
	share_deltas(pix.xy, Mass, Delta2, Delta);
}


#pragma kernel copy_all
[numthreads(8, 8, 1)]
void copy_all(uint3 pix : SV_DispatchThreadID)
{
	Delta[at(pix.xy)] = Delta2[at(pix.xy)];
}